(ns codox.utils
  "Miscellaneous utility functions."
  (:require [clojure.java.io :as io]
            [clojure.string :as str]))

(defn- empty-seq? [x]
  (and (seqable? x) (not (seq x))))

(defn remove-empties [m]
  (into {} (filter (comp not empty-seq? second) m)))

(defn assoc-some
  "Associates a key with a value in a map, if and only if the value is not nil."
  ([m k v]
     (if (nil? v) m (assoc m k v)))
  ([m k v & kvs]
     (reduce (fn [m [k v]] (assoc-some m k v))
             (assoc-some m k v)
             (partition 2 kvs))))

(defn update-some
  "Updates a key in a map with a function, if and only if the return value from
  the function is not nil."
  [m k f & args]
  (assoc-some m k (apply f (m k) args)))

(defn- find-minimum [coll]
  (if (seq coll)
    (apply min coll)))

(defn- find-smallest-indent [text]
  (->> (str/split-lines text)
       (remove str/blank?)
       (map #(re-find #"^\s+" %))
       (map count)
       (find-minimum)))

(defn is-absolute? [file]
  (and file (.isAbsolute (io/file file))))

(defn- find-file-in-repo
  "Given a classpath-relative `file` (as from the output of
   `codox.reader.clojure/read-namespaces`), and a sequence of `sources`
   representing the classpaths, returns a File object `file` relative
   to the repo root."
  [file sources]
  (->> (map #(io/file % file) sources)
       (filter #(.exists %))
       first))

(defn canonical-path [file]
  (.getCanonicalPath (io/file file)))

(defn unindent
  "Unindent a block of text by a specific amount or the smallest common
  indentation size."
  ([text]
     (unindent text (find-smallest-indent text)))
  ([text indent-size]
     (let [re (re-pattern (str "^\\s{0," indent-size "}"))]
       (->> (str/split-lines text)
            (map #(str/replace % re ""))
            (str/join "\n")))))

(defn correct-indent [text]
  (if text
    (let [lines (str/split-lines text)]
      (->> (rest lines)
           (str/join "\n")
           (unindent)
           (str (first lines) "\n")))))

(defn uri-path [path]
  (str/replace (str path) java.io.File/separator "/"))

(defn normalize-path [path root]
  (when path
    (let [root (str (uri-path root) "/")
          path (uri-path (.getAbsolutePath (io/file path)))]
      (if (.startsWith path root)
        (.substring path (.length root))
        path))))

(defn- dejarify
  "Return the classpath relative file for `file`.

  Some manipulated metadata analysis :file elements (from techniques such as
  potemkin import-vars) can point to a file inside the jar instead of the file
  on file system when codox is invoked from cljdoc. This could likely be
  handled by altering the classpath cljdoc uses, but we handle the case
  here none-the-less.

  Oddly, the syntax of the file url is missing the jar: prefix so we add that
  if needed before converting."
  [file]
  (if (re-find #"^(jar:)?file:/.*\.jar!/" file)
    (->> (if (str/starts-with? file "jar:") file (str "jar:" file))
         java.net.URL.
         .openConnection
         (cast java.net.JarURLConnection)
         .getEntryName)
    file))

(defn normalize-to-source-path
  [source-path file]
  (when file
    (let [file (dejarify file)]
      (if (.exists (io/file file))
        (normalize-path file source-path)
        file))))

(defn add-source-paths
  "Accepts `ns-seq`, a sequence of namespaces (generated by
   `codox.reader.clojure/read-namespaces` or
   `codox.reader.clojurescript/read-namespaces`), the project directory
  `root`, and a list of `sources` directories.
   Returns the sequence of namespaces with `:path` added to `:publics` ns
   var entries, which is just `:file` relative to the repo `root`."
  [ns-seq root sources]
  (for [ns ns-seq]
    (assoc ns
           :publics (map #(let [f (:file %)
                                p (if (.exists (io/file f))
                                    (normalize-path f root)
                                    (normalize-path (find-file-in-repo f sources) root))]
                            (assoc % :path (and p (io/file p))))
                         (:publics ns)))))

(defn summary
  "Return the summary of a docstring.
   The summary is the first portion of the string, from the first
   character to the first page break (\f) character OR the first TWO
   newlines."
  [s]
  (if s
    (->> (str/trim s)
         (re-find #"(?s).*?(?=\f)|.*?(?=\n\n)|.*"))))

(defn public-vars
  "Return a list of all public var names in a collection of namespaces from one
  of the reader functions."
  [namespaces]
  (for [ns  namespaces
        var (:publics ns)
        v   (concat [var] (:members var))]
    (symbol (str (:name ns)) (str (:name v)))))

(def ^:private re-chars (set "\\.*+|?()[]{}$^"))

(defn re-escape
  "Escape a string so it can be safely placed in a regex."
  [s]
  (str/escape s #(if (re-chars %) (str \\ %))))

(defn search-vars
  "Find the best-matching var given a partial var string, a list of namespaces,
  and an optional starting namespace."
  [namespaces partial-var & [starting-ns]]
  (let [regex   (if (.contains partial-var "/")
                  (re-pattern (str (re-escape partial-var) "$"))
                  (re-pattern (str "/" (re-escape partial-var) "$")))
        matches (filter
                 #(re-find regex (str %))
                 (public-vars namespaces))]
    (or (first (filter #(= (str starting-ns) (namespace %)) matches))
        (first matches))))
